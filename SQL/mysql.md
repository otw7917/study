- **SELECT** : 보여주고자 하는 데이터 **IFNULL(column, replaced_value)** as
- **FROM** : 어디 테이블
- **WHERE** : 조건 AND, OR
- **ORDER** BY : 순서[ ..[..조건 우선순위 하이], [조건 우선순위 로우] ] - **ASC**:default, **DESC**

```sql
-- 12세 이하인 여자 환자 목록 출력하기
SELECT PT_NAME,PT_NO,GEND_CD, AGE, IFNULL(TLNO, 'NONE') as TLNO
FROM PATIENT
WHERE AGE<=12 AND GEND_CD="W"
ORDER BY AGE DESC, PT_NAME
```

**DATE**

- DATE_FORMAT(VALUE, FORMAT)
- YEAR, MONTH, DAY, DAYNAME..

```sql
-- 3월에 태어난 여성 회원 목록 출력
SELECT MEMBER_ID, MEMBER_NAME, GENDER, DATE_FORMAT(DATE_OF_BIRTH, "%Y-%m-%d") as DATE_OF_BIRTH
FROM MEMBER_PROFILE
WHERE  MONTH(DATE_OF_BIRTH) = 3 AND TLNO IS NOT NULL AND GENDER="W"
ORDER BY MEMBER_ID
```

---

**GROUP BY** 데이터 그룹화 - column 기준
**HAVING** 데이터 그룹화 조건

```sql
-- 재구매가 일어난 상품과 회원 리스트 구하기
-- https://school.programmers.co.kr/learn/courses/30/lessons/131536
SELECT USER_ID, PRODUCT_ID, SALES_AMOUNT, SUM(SALES_AMOUNT)
FROM ONLINE_SALE
# WHERE USER_ID = 15
GROUP BY USER_ID, PRODUCT_ID
HAVING COUNT(USER_ID) > 1
ORDER BY USER_ID ASC, PRODUCT_ID DESC
-- HAVING 재구매의 경우 행이 2개이상이 될것
```

---

**WHERE IN** 여러값을 비교해야할 경우!
**DATE_FORMAT(COLUMN NAME, FORMAT)** //(PostgreSQL) TO_CHAR

```sql
-- https://school.programmers.co.kr/learn/courses/30/lessons/132203
SELECT DR_NAME, DR_ID,  MCDP_CD ,DATE_FORMAT(HIRE_YMD, '%Y-%m-%d') as HIRE_YMD
FROM DOCTOR
-- WHERE MCDP_CD = 'CS' OR MCDP_CD = 'GS'
WHERE MCDP_CD IN ('CS', 'GS')
ORDER BY HIRE_YMD DESC, DR_NAME ASC
```

**JOIN** defalut -> inner join 공통된 부분만

```sql
-- 조건에 맞는 도서와 저자 리스트 출력하기
SELECT BOOK.BOOK_ID, AUTHOR.AUTHOR_NAME, DATE_FORMAT(BOOK.PUBLISHED_DATE, "%Y-%m-%d") as PUBLISHED_DATE
FROM BOOK
JOIN AUTHOR
ON BOOK.AUTHOR_ID = AUTHOR.AUTHOR_ID
WHERE BOOK.CATEGORY = '경제'
ORDER BY PUBLISHED_DATE
```

**SUM**
**USING** JOIN ON 축약 하려고 쓰는거 // 각 테이블의 컬럼명이 같을 경우에만 쓸수 있다?

- ON PRODUCT.PRODUCT_ID = OFFLINE_SALE.PRODUCT_ID -> USING (PRODUCT_ID)

```sql
-- 상품 별 오프라인 매출 구하기
SELECT PRODUCT.PRODUCT_CODE, SUM(PRODUCT.PRICE * OFFLINE_SALE.SALES_AMOUNT) AS SALES
FROM PRODUCT
JOIN OFFLINE_SALE
-- ON PRODUCT.PRODUCT_ID = OFFLINE_SALE.PRODUCT_ID
USING (PRODUCT_ID)
GROUP BY PRODUCT_CODE
ORDER BY SALES DESC, PRODUCT_CODE ASC
```

**GROUP BY** COUNT(), MAX(), MIN(), SUM(), AVG()

```sql
--성분으로 구분한 아이스크림 총 주문량
SELECT ICECREAM_INFO.INGREDIENT_TYPE, SUM(FIRST_HALF.TOTAL_ORDER) AS TOTAL_ORDER
FROM FIRST_HALF
JOIN ICECREAM_INFO
USING (FLAVOR)
GROUP BY ICECREAM_INFO.INGREDIENT_TYPE
ORDER BY TOTAL_ORDER
```

**HAVING** 그룹화 한 조건. where에 같이 주는 실수..

```sql
SELECT USED_GOODS_BOARD.WRITER_ID AS USER_ID, USED_GOODS_USER.NICKNAME, SUM(USED_GOODS_BOARD.PRICE) AS TOTAL_SALES
FROM USED_GOODS_BOARD INNER JOIN USED_GOODS_USER
ON USED_GOODS_BOARD.WRITER_ID = USED_GOODS_USER.USER_ID
WHERE USED_GOODS_BOARD.STATUS="DONE"
GROUP BY USED_GOODS_BOARD.WRITER_ID
HAVING TOTAL_SALES >= 700000
ORDER BY TOTAL_SALES
```

**LIKE** 조건에 맞는 어떻게 보면 정규표현식 같은.
**REGEXP**

```sql
-- 자동차 종류 별 특정 옵션이 포함된 자동차 수 구하기
SELECT CAR_TYPE, COUNT(CAR_ID) AS CARS
FROM CAR_RENTAL_COMPANY_CAR
-- WHERE OPTIONS REGEXP '열선시트|통풍시트|가죽시트' -> '시트'만 줘도 문제는 풀렸
-- WHERE OPTIONS LIKE "%시트%"
-- OPTIONS를 다른 테이블로 정규화 시키고 IN으로 찾으면 아주 좋겠군.
WHERE OPTIONS LIKE "%열선시트%" OR OPTIONS LIKE "%통풍시트%" OR OPTIONS LIKE "%가죽시트%"
GROUP BY CAR_TYPE
ORDER BY CAR_TYPE
```

---

**DISTINCT** : 컬럼이 중복되는 경우 제외해주기
**WITH** Common Table Expression을 정의하기 위해 사용 (서브쿼리와 비슷한 role)

<!--비트연산
-- 예를 들어 400인경우
1|1|0|0|1|0|0|0|0| 둘다 1인경우 리턴 1 비트연산 &
0|0|0|0|1|0|0|0|0| -> Javascript
0|0|0|0|1|0|0|0|0| -> Javascript ✅
-->

**솔루션**

```sql
-- FrontEnd 개발자 찾기 🔥
WITH FESTACK AS (
    SELECT *
    FROM SKILLCODES
    WHERE CATEGORY LIKE '%Front End%'
)

SELECT DISTINCT ID, EMAIL, FIRST_NAME, LAST_NAME
FROM DEVELOPERS
JOIN FESTACK
ON DEVELOPERS.SKILL_CODE & FESTACK.CODE = FESTACK.CODE
ORDER BY ID
```

**솔루션 2**

```sql
-- FrontEnd 개발자 찾기 🔥
SELECT
    ID
    , EMAIL
    , FIRST_NAME
    , LAST_NAME
FROM
    DEVELOPERS
WHERE
    SKILL_CODE & (
        SELECT
            SUM(CODE)
        FROM
            SKILLCODES
        WHERE
            CATEGORY = 'Front End'
    )
ORDER BY ID
```

---

**alias** `table` `alias` ex) `FROM USED_GOODS_BOARD B`
**YEAR, MONTH**

```sql
-- 조건에 부합하는 중고거래 댓글 조회하기 select
SELECT B.TITLE, B.BOARD_ID, R.REPLY_ID, R.WRITER_ID, R.CONTENTS, DATE_FORMAT(R.CREATED_DATE, "%Y-%m-%d") AS CREATED_DATE
FROM USED_GOODS_BOARD B
JOIN USED_GOODS_REPLY R
USING (BOARD_ID)
WHERE YEAR(B.CREATED_DATE) = 2022 AND MONTH(B.CREATED_DATE) = "10"
ORDER BY R.CREATED_DATE ASC, B.TITLE ASC
```

```sql
-- 특정 물고기를 잡은 총 수 구하기
-- # SELECT *
SELECT COUNT(FI.ID) as FISH_COUNT
FROM FISH_INFO FI
JOIN FISH_NAME_INFO FNI
ON FI.FISH_TYPE = FNI.FISH_TYPE
WHERE FNI.FISH_NAME = "BASS" OR FNI.FISH_NAME = "SNAPPER"
```

**GROUP BY** 여러 조건을 그룹화 할 수 있음.
**CTE WITH** 를 사용할 경우 WITH TABLE (), WITH TABLE() ❌ WITH TABLE (), TABLE () ✅

```sql
-- 대여 횟수가 많은 자동차들의 월별 대여 횟수 구하기 -> 총 5회 이상 자동차 그룹 중에서 월별 횟수를 구하기
# 총 대여 횟수가 5회 이상인 자동차 그룹
WITH MORE_THAN_FIVE_RENTAL AS (
    SELECT CAR_ID
    FROM CAR_RENTAL_COMPANY_RENTAL_HISTORY
    WHERE MONTH(START_DATE) >= 8 AND MONTH(START_DATE) <= 10
    GROUP BY CAR_ID
    HAVING COUNT(*) >= 5
),

-- # 월별 해당 CAR_ID가 얼마나 빌렸는지
MONTHLY_CAR_RECORD AS (
    SELECT MONTH(START_DATE) AS MONTH, CAR_ID, COUNT(*) AS RECORDS
    FROM CAR_RENTAL_COMPANY_RENTAL_HISTORY
    WHERE MONTH(START_DATE) >= 8 AND MONTH(START_DATE) <= 10
    GROUP BY CAR_ID, MONTH(START_DATE)
)
SELECT MONTHLY_CAR_RECORD.MONTH, MONTHLY_CAR_RECORD.CAR_ID, MONTHLY_CAR_RECORD.RECORDS
FROM MONTHLY_CAR_RECORD
JOIN MORE_THAN_FIVE_RENTAL
USING(CAR_ID)
ORDER BY MONTHLY_CAR_RECORD.MONTH, MONTHLY_CAR_RECORD.CAR_ID DESC

```
